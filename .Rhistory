for(i in 1:3){tmp <- aerial_image[[i]]
layer_tmp <- c(layer_tmp, tmp)}
layer_tmp = NULL
for(i in 1:3){tmp <- aerial_image[[i]]
layer_tmp <- c(layer_tmp, tmp)}
layer <- 1:3
layer <- 1:3
x = aerial_image
layer_tmp = NULL
for(i in 1:3){tmp <- x[[i]],layer_tmp <- c(layer_tmp, tmp)}
layer <- 1:3
x = aerial_image
layer_tmp = NULL
for(i in layer){tmp <- x[[i]],layer_tmp <- c(layer_tmp, tmp)}
for(i in layer){tmp <- x[[i]]
layer_tmp <- c(layer_tmp, tmp)}
test <- lapply(layer_tmp, focal(layer_tmp, w = windowsize[[1]], fun = as.name(fun[[1]])))
test <- lapply(layer_tmp, focal(layer_tmp, w = windowsize[[1]], fun = mean))
?lapply
test <- lapply(layer_tmp, focal)
w = matrix(1,3,3)
fun = mean
test <- lapply(layer_tmp, focal)
test <- lapply(layer_tmp, focal(x, w = w, fun = fun))
test <- lapply(layer_tmp, focal(x, w = w, fun = fun))
test <- lapply(layer_tmp, focal(w = w, fun = fun))
test <- lapply(layer_tmp, focal(w = w, fun = fun))
test <- c(layer_tmp, list(matrix(1,3,3), matrix(1,5,5)))
test <- c(layer_tmp, list(matrix(1,3,3), matrix(1,5,5)))
test
test <- c(layer_tmp[[1]], list(matrix(1,3,3), matrix(1,5,5)))
test
test = NULL
test = NULL
for(i in 1:3){
tmp <-c(layer_tmp[[i]], list(matrix(1,3,3), matrix(1,5,5)))
test <- c(test, tmp)
}
test
test = NULL
for(i in 1:3){
tmp <-c(layer_tmp[[i]], list(matrix(1,3,3), matrix(1,5,5)))
test <- list(test, tmp)
}
test
test <- list(c(layer_tmp[[1]], list(matrix(1,3,3), matrix(1,5,5))),
c(layer_tmp[[2]], list(matrix(1,3,3), matrix(1,5,5))),
c(layer_tmp[[3]], list(matrix(1,3,3), matrix(1,5,5))))
test
layers = c(aerial_image[[1]], aerial_image[[2]], aerial_image[[3]])
test <- list(c(layers[[1]], windowsize,
test
test <- list(c(layers[[1]], windowsize),
test
test_all <- list(c(test[[1]], mean),
c(test[[2]], max))
test_all
test <- lapply(test_all, focal)
i = 1
length(layers)
layers = c(aerial_image[[1]], aerial_image[[2]], aerial_image[[3]])
windowsize <- list(matrix(1,3,3), matrix(1,5,5))
fun <- list("mean", "min")
i = 1
j = 1
f = 1
temp_layer_fun <- focal(x = layers[[i]], w = windowsize[[j]], fun = fun[[f]])
for(f in length(fun)){
temp_layer_fun <- focal(x = layers[[i]], w = windowsize[[j]], fun = fun[[f]])
temp_stack_fun <- stack(temp_stack_fun, temp_layer_fun)
}
temp_stack_fun = NULL
temp_stack_w = NULL
temp_stack = NULL
for(i in length(layers)){
for(j in length(windowsize)){
for(f in length(fun)){
temp_layer_fun <- focal(x = layers[[i]], w = windowsize[[j]], fun = fun[[f]])
temp_stack_fun <- stack(temp_stack_fun, temp_layer_fun)
}
temp_layer_w <- temp_stack_fun
temp_stack_w <- stack(temp_stack_w, temp_layer_w)
}
temp_layer <- temp_stack_w
temp_stack <- stack(temp_stack, temp_layer)
}
temp_stack_fun = NULL
temp_stack_w = NULL
temp_stack = NULL
i = 1
j = 1
f = 1
for(f in length(fun)){
temp_layer_fun <- focal(x = layers[[i]], w = windowsize[[j]], fun = fun[[f]])
temp_stack_fun <- stack(temp_stack_fun, temp_layer_fun)
}
fun[[f]]
fun <- list("mean", "min")
layers = c(aerial_image[[1]], aerial_image[[2]], aerial_image[[3]])
windowsize <- list(matrix(1,3,3), matrix(1,5,5))
fun <- list("mean", "min")
temp_layer_fun <- focal(x = layers[[i]], w = windowsize[[j]], fun = fun[[f]])
fun[[f]]
temp_layer_fun <- focal(x = layers[[i]], w = windowsize[[j]], fun = mean)
temp_stack_fun <- stack(temp_stack_fun, temp_layer_fun)
testomat <- lapply(layers, function(layers, windowsize){
dk <- lapply(windowsize, focal(x = layer, w = windowsize, fun = mean))
})
testomat <- lapply(layers, focal(layers, w = matrix(1,3,3), fun = mean))
testomat <- lapply(layers, focal(w = matrix(1,3,3), fun = mean))
filter_mean_3x3 <- NULL
for(i in 1:3){
tmp <- focal(uniwald_aerial[[i]], w=matrix(1,3,3), fun=mean)
filter_mean_3x3 <- stack(filter_mean_3x3, tmp)
}
filter_mean_3x3 <- NULL
for(i in 1:3){
tmp <- focal(aerial_image[[i]], w=matrix(1,3,3), fun=mean)
filter_mean_3x3 <- stack(filter_mean_3x3, tmp)
}
rm(filter_mean_3x3)
exists(filter_mean_3x3)
exists("filter_mean_3x3")
for(i in 1:3){
tmp <- focal(aerial_image[[i]], w=matrix(1,3,3), fun=mean)
if(exists("filter_mean_3x3")){
filter_mean_3x3 <- stack(filter_mean_3x3, tmp)
}
else{
filter_mean_3x3 <- tmp
}
}
## apply smoothing algorithms and filters
# mean filter, 3x3 window
for(i in 1:3){
tmp <- focal(aerial_image[[i]], w=matrix(1,3,3), fun=mean, na.rm =T)
if(exists("filter_mean_3x3")){
filter_mean_3x3 <- stack(filter_mean_3x3, tmp)
}
else{
filter_mean_3x3 <- tmp
}
}
rm(filter_mean_3x3)
## apply smoothing algorithms and filters
# mean filter, 3x3 window
for(i in 1:3){
tmp <- focal(aerial_image[[i]], w=matrix(1,3,3), fun=mean, na.rm =T)
if(exists("filter_mean_3x3")){
filter_mean_3x3 <- stack(filter_mean_3x3, tmp)
}
else{
filter_mean_3x3 <- tmp
}
}
# Sobel filter
for(i in 1:3){
tmp <- focal(aerial_image[[i]], w=matrix(c(1,2,1,0,0,0,-1,-2,-1) / 4, nrow=3))
if(exists("filter_sobel")){
filter_sobel <- stack(filter_sobel, tmp)
}
else{
filter_sobel <- tmp
}
}
# mean filter, 5x5 window
for(i in 1:3){
tmp <- focal(aerial_image[[i]], w=matrix(1,5,5), fun=mean, na.rm =T)
if(exists("filter_mean_5x5")){
filter_mean_5x5 <- stack(filter_mean_5x5, tmp)
}
else{
filter_mean_5x5 <- tmp
}
}
?focal
uwc_all <- stack(aerial_image, indices_rgb, filter_mean_3x3, filter_mean_5x5, filter_sobel)
uwc_all
names(filter_mean_3x3) <-(c("mean_3_r", "mean_3_g", "mean_3_b"))
filter_mean_3x3
names(filter_mean_5x5) <-(c("mean_5_r", "mean_5_g", "mean_5_b"))
?sd
# standard deviation, 5x5
for(i in 1:3){
tmp <- focal(aerial_image[[i]], w=matrix(1,5,5), fun=sd, na.rm =T)
if(exists("sd_5x5")){
sd_5x5 <- stack(sd_5x5, tmp)
}
else{
sd_5x5 <- tmp
}
}
lidar_files <- file.path(envrmt$path_level0,"tiles")
output_terrain <- file.path(envrmt$path_output, paste0("dem", filetype))
dem <- lidar_terrain(lidar_files, aoi, proj4, output = output_terrain)
install.packages("uavRst")
## CHM
mof_lidar <- lidR::lasclipRectangle(lidar_files, xleft = aoi[1], ybottom = aoi[3], xright = aoi[2], ytop = aoi[4])
### Calculate DEM and other terrain properties from LiDAR data
## DEM
lidar_files <- file.path(envrmt$path_level0,"tiles")
## CHM
mof_lidar <- lidR::lasclipRectangle(lidar_files, xleft = aoi[1], ybottom = aoi[3], xright = aoi[2], ytop = aoi[4])
# 1 - define packages ------------------------------------------------------------------
libs <- c("lidR",
"raster",
"sf",
"mapview",
"CAST",
"caret",
"parallel",
"lidR") # sf needed for reading in shapefile
source("setEnvironment2.R")
## CHM
mof_lidar <- lidR::lasclipRectangle(lidar_files, xleft = aoi[1], ybottom = aoi[3], xright = aoi[2], ytop = aoi[4])
lidar_files
### Calculate DEM and other terrain properties from LiDAR data
## DEM
lidar_files <- list.files(envrmt$path_data_lidar_level0, pattern = glob2rx("*.las"), full.names = TRUE)
### Calculate DEM and other terrain properties from LiDAR data
## DEM
lidar_files <- list.files(envrmt$path_level0, pattern = glob2rx("*.las"), full.names = TRUE)
## CHM
mof_lidar <- lidR::lasclipRectangle(lidar_files, xleft = aoi[1], ybottom = aoi[3], xright = aoi[2], ytop = aoi[4])
lidar_files
## CHM
mof_lidar <- lidR::lasclipRectangle(lidR::readLAS(las_files[1]), xleft = aoi[1], ybottom = aoi[3], xright = aoi[2], ytop = aoi[4])
## CHM
mof_lidar <- lidR::lasclipRectangle(lidR::readLAS(lidar_files[1]), xleft = aoi[1], ybottom = aoi[3], xright = aoi[2], ytop = aoi[4])
mof_lidar = lasground(mof_lidar, csf()) #works fine without the need to tune the parameters
mof_lidar = lasnormalize(mof_lidar, tin()) #removing topograhpy
# create canopy height model
chm <- grid_canopy(core_aoimof, 0.5, p2r(0.3))
ker <- matrix(1,3,3)
chm <- raster::focal(chm, w = ker, fun = mean, na.rm = TRUE)
# create canopy height model
chm <- grid_canopy(mof_lidar, 0.5, p2r(0.3))
ker <- matrix(1,3,3)
chm <- raster::focal(chm, w = ker, fun = mean, na.rm = TRUE)
plot(chm)
mof_seg = lidR::watershed(chm, th_tree = 4)()
contour = rasterToPolygons(mof_seg, dissolve = TRUE)
## create segmenation with raster output; using watershed algorithm
mof_seg <- lidR::watershed(chm, th_tree = 4)()
# 1 - define packages ------------------------------------------------------------------
libs <- c("lidR",
"raster",
"sf",
"mapview",
"CAST",
"caret",
"parallel",
"lidR",
"EBImage") # sf needed for reading in shapefile
source("setEnvironment2.R")
install.packages("BiocManager")
BiocManager::install("EBImage")
mof_seg <- lidR::watershed(chm, th_tree = 4)()
contour <- rasterToPolygons(mof_seg, dissolve = TRUE)
# 4 - start code ----------------------------------------------------------------------------------------------------------------------------------
## Get aerial Images and crop them to the chosen extent
#aerial_files <- list.files(envrmt$path_aerial, pattern = "\\.tif$", full.names = T)
#aerial_output <- file.path(envrmt$path_output, paste0("aerial_uwc", filetype))
#aerial_image <- read_and_crop(aerial_files, aoi, output = aerial_output, parallel = T)
predStack <- stack("F:/Studium/WiSe19/OpenGeoHub_2019/practice/data/predictors.grd")
# 4 - start code ----------------------------------------------------------------------------------------------------------------------------------
## Get aerial Images and crop them to the chosen extent
#aerial_files <- list.files(envrmt$path_aerial, pattern = "\\.tif$", full.names = T)
#aerial_output <- file.path(envrmt$path_output, paste0("aerial_uwc", filetype))
#aerial_image <- read_and_crop(aerial_files, aoi, output = aerial_output, parallel = T)
aerial_image <- stack("F:/Studium/WiSe19/OpenGeoHub_2019/practice/data/predictors.grd")
plot(aerial_image)
plotRGB(aerial_image)
aerial_image <- aerial_image[[c(1:3)]]
plotRGB(aerial_image)
plot(aerial_image)
extent(aerial_image)
ibs <- c("lidR",
"raster",
"sf",
"mapview",
"CAST",
"caret",
"parallel",
"lidR",
"EBImage") # sf needed for reading in shapefile
# 2 - set Environment ------------------------------------------------------------------------------------------------------------------------------
source("setEnvironment2.R")
# 4 - start code ----------------------------------------------------------------------------------------------------------------------------------
## Get aerial Images and crop them to the chosen extent
#aerial_files <- list.files(envrmt$path_aerial, pattern = "\\.tif$", full.names = T)
#aerial_output <- file.path(envrmt$path_output, paste0("aerial_uwc", filetype))
#aerial_image <- read_and_crop(aerial_files, aoi, output = aerial_output, parallel = T)
aerial_image <- stack(paste0(envrmt$path_data, "hanna/predictors.grd"))
# 1 - define packages ------------------------------------------------------------------
libs <- c("lidR",
"raster",
"sf",
"mapview",
"CAST",
"caret",
"parallel",
"lidR",
"EBImage") # sf needed for reading in shapefile
source("setEnvironment2.R")
# 4 - start code ----------------------------------------------------------------------------------------------------------------------------------
## Get aerial Images and crop them to the chosen extent
#aerial_files <- list.files(envrmt$path_aerial, pattern = "\\.tif$", full.names = T)
#aerial_output <- file.path(envrmt$path_output, paste0("aerial_uwc", filetype))
#aerial_image <- read_and_crop(aerial_files, aoi, output = aerial_output, parallel = T)
aerial_image <- stack(paste0(envrmt$path_data, "hanna/predictors.grd"))
paste0(envrmt$path_data, "hanna/predictors.grd")
# 4 - start code ----------------------------------------------------------------------------------------------------------------------------------
## Get aerial Images and crop them to the chosen extent
#aerial_files <- list.files(envrmt$path_aerial, pattern = "\\.tif$", full.names = T)
#aerial_output <- file.path(envrmt$path_output, paste0("aerial_uwc", filetype))
#aerial_image <- read_and_crop(aerial_files, aoi, output = aerial_output, parallel = T)
aerial_image <- stack(paste0(envrmt$path_data, "/hanna/predictors.grd"))
okay <- stack("/media/jonas/RemoteSensingETC/Studium/Marburg/WS19/mpg-envinsys-plygrnd/OpenGeoHub_2019/practice/data/predictors.grd")[[c("red","green","blue","vvi","pca","pca_5_sd")]]
not_okay <- stack("/media/jonas/RemoteSensingETC/Studium/Marburg/WS19/mpg-envinsys-plygrnd/OpenGeoHub_2019/practice/data/predictors.grd")
not_okay <- stack("/media/jonas/RemoteSensingETC/Studium/Marburg/WS19/mpg-envinsys-plygrnd/OpenGeoHub_2019/practice/data/predictors.grd")
require(raster)
okay <- stack("/media/jonas/RemoteSensingETC/Studium/Marburg/WS19/mpg-envinsys-plygrnd/OpenGeoHub_2019/practice/data/predictors.grd")[[c("red","green","blue","vvi","pca","pca_5_sd")]]
gehts <- getValues(okay)
View(gehts)
okay2 <- na.omit(gehts)
# 1 - define packages ------------------------------------------------------------------
libs <- c("lidR",
"raster",
"sf",
"caret",
"randomForest",
"mapview") # sf needed for reading in shapefile
source("setEnvironment.R")
hey <- list("gruen", "rot", "blau")
for(i in hey){
i
}
for(i in hey){
print(i)
}
require(link2GI)
#
#############################  SET VARIABLES HERE  ###################################
# Set working directory
source("setEnvironment.R")
require(sf)
# 1 - define packages ------------------------------------------------------------------
libs <- c("lidR",
"raster",
"sf",
"mclust",
"parallel",
"mmand",
"RColorBrewer",
"mapview")
source("setEnvironment3.R")
libs <- c("sf",
"ggplot2",
"hrbrthemes",
"cowplot")
source("setEnvironment3.R")
hrbrthemes::import_roboto_condensed()
files <- list(lidar = file.path(envrmt$path_segments, "lidar_categorised_segments.gpkg"),
rgb = file.path(envrmt$path_segments, "rgb_categorised_segments.gpkg"),
manual = file.path(envrmt$path_segments, "crowns_manual_categorised_segments.gpkg"))
vector_list <- lapply(files, function(path){
vector <- st_read(path)
# Transforming all to UTM 32N
vector_t <- st_transform(vector, "+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs")
# Calculating m?
vector_t$area_m2 <- as.numeric(st_area(vector_t))
#vector_t$log_m2 <- log(vector_t$area_m2)
return(vector_t)
})
## limit to segments, which contain trees (are not NA)
trees <- lapply(vector_list, function(element){
## remove "sonstiges" from categorised segments
element <- element[which(element$spec != "Sonstiges"),]
trees <- element[!is.na(element$tspec),]
return(trees)
})
names <- c("lidar", "rgb", "manual")
for(i in 1:3){
trees[[i]]$segmentation <- names[i]
}
trees[[1]] <- trees[[1]][-1]
trees[[2]] <- trees[[2]][-1]
all_df <- do.call(rbind, trees)
ggplot(data = all_df, aes(fill=segmentation, y=area_m2, x=spec)) +
geom_violin(position="dodge", alpha=0.5, outlier.colour="transparent") +
theme_ipsum()  +
#scale_y_log10() +
xlab("") +
ylab("Tip (%)") +
ylim(0, 300)
match(c(NA, 1, 2, 3), c(1,2,3))
match(c(NA, 1, 2, 3), c(NA,1,2,3))
install.packages("RStoolbox")
require(RStoolbox)
libs <- c("sf",
"ggplot2",
"hrbrthemes",
"cowplot",
"raster",
"RColorBrewer")
source("setEnvironment3.R")
install.packages("devtools")
install.packages("roxygen2")
install.packages("roxygen2")
install.packages("devtools")
install.packages(c("dplyr", "ggplot2", "tidyr", "zoo"))
if(c(T,T,F)) print("True")
library(usethis)
proj_sitrep
proj_sitrep()
proj_get()
setwd("~/google-drive/Studium/Marburg/SS20/2_Gelaendeklima/05_R_Package/energyBudget")
proj_get()
usethis::use_testthat()
usethis::use_test()
sand <- c(0.269,1.46,1.98,2.18,2.31,2.49,2.58)
x <- 2.5
dif <- (sand[2]-sand[1])/5
dif*x
sand[7]
# fuer Sand mit Hilfe der Bodenfeuchte x (in Vol-%)
#' Title
#'
#' @param moisture
#' @param texture
#'
#' @return
#' @export
#'
#' @examples
soil_thermal_cond <- function(moisture, texture = "sand") {
if(texture == "sand"){
y <- c(0.269,1.46,1.98,2.18,2.31,2.49,2.58)
} else if(texture == "clay"){
y <- c(0.276,0.586,1.1,1.43,1.57,1.74,1.95)
} else {
stop("Texture not available. Input either 'sand' or 'clay'")
}
x <- c(0, 5, 10, 15, 20, 30, 43)
# linear interpolation of values
thermal_cond <- approx(x, y, xout = moisture, yleft = NA, yright = y[7])
}
moisture <- c(-4, 0, 2.5, 10, 17, 21, 33, 45)
soil_thermal_cond(moisture)
# fuer Sand mit Hilfe der Bodenfeuchte x (in Vol-%)
#' Title
#'
#' @param moisture
#' @param texture
#'
#' @return
#' @export
#'
#' @examples
soil_thermal_cond <- function(moisture, texture = "sand") {
if(texture == "sand"){
y <- c(0.269,1.46,1.98,2.18,2.31,2.49,2.58)
} else if(texture == "clay"){
y <- c(0.276,0.586,1.1,1.43,1.57,1.74,1.95)
} else {
stop("Texture not available. Input either 'sand' or 'clay'")
}
x <- c(0, 5, 10, 15, 20, 30, 43)
# linear interpolation of values
return(approx(x, y, xout = moisture, yleft = NA, yright = y[7]))
}
soil_thermal_cond(moisture)
# fuer Sand mit Hilfe der Bodenfeuchte x (in Vol-%)
#' Title
#'
#' @param moisture
#' @param texture
#'
#' @return
#' @export
#'
#' @examples
soil_thermal_cond <- function(moisture, texture = "sand") {
if(texture == "sand"){
y <- c(0.269,1.46,1.98,2.18,2.31,2.49,2.58)
} else if(texture == "clay"){
y <- c(0.276,0.586,1.1,1.43,1.57,1.74,1.95)
} else {
stop("Texture not available. Input either 'sand' or 'clay'")
}
x <- c(0, 5, 10, 15, 20, 30, 43)
# linear interpolation of values
therm_cond <- approx(x, y, xout = moisture, yleft = NA, yright = y[7])
return(therm_cond$y)
}
soil_thermal_cond(moisture)
soil_thermal_cond(moisture, texture = "hallo")
devtools::document()
rm(list = c("soil_thermal_cond"))
devtools::document()
devtools::load_all()
?soil_vol_heat_cap
devtools::document()
?soil_vol_heat_cap
devtools::document()
?soil_vol_heat_cap
devtools::document()
?soil_vol_heat_cap
devtools::document()
?soil_vol_heat_cap
devtools::document()
